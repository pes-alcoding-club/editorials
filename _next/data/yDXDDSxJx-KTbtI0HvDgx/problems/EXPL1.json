{"pageProps":{"editorialData":{"editorial":"<p>Title: Exploring Planets<br>\nDifficulty: Hard<br>\nPrerequisites: Backtracking, BFS<br>\nTime Complexity:O(n!)<br>\nMethod Used: Backtracking, DFS<br>\nInstructions:<br>\nWe use a backtracking algorithm to find the maximum number of planets visited.</p>\n<ol>\n<li>Initially, the max number of planets visited is set to zero. The first step is to find a planet such that, the time taken to travel from Earth to that planet is less than or equal to <b>X</b>. Once this planet is found, the element in the <b>visited array</b> corresponding to this planet is set to 1.</li>\n<li>We call the function which will help us find the most planets visited.</li>\n<li>There exists a variable that keeps track of the time taken by the current best path. (The best path is the one that covers the most planets while taking the least time to cover these planets). There exists a temporary array to keep track of the current path <b>temp</b> and another array to keep track of the best path <b>ans</b>.</li>\n<li>In the backtracking function, the following procedure takes place:It iterates through a row of the 2-dimensional matrix. This row is the current planet that the rocket is on. If a particular planet is not visited and the time taken to reach it from the current planet is within the limit, then that particular planet is marked as visited, and this planet is added to the temporary array. If from a particular path, there exists no way to proceed further, then the current path status is compared with the best path status, and it is updated if necessary. The same goes on until a way to proceed is found. This is known as backtracking.</li>\n</ol>\n","solutions":{"cpp":"// Problem Name: Exploring Planets\n// Difficulty : Hard\n// Tags : Backtracking, DFS\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid func(vector<vector<int>> d2, vector<bool> visit, int time_left, int& time_left_max, int curr, int n, int count, int& max, vector<int> temp, vector<int> &ans)\n{\n    if(count == n)\n    {\n        if(count>max)\n\t{\n            max = count;\n\t    ans = temp;\n       \t    time_left_max = time_left;\n\t}\n\tif((count==max) && (time_left > time_left_max))\n\t{\n\t    ans = temp;\n\t    time_left_max = time_left;\n\t}\n        return;\n    }\n\n    int flag = 0;\n    for(int i=0; i<n; i++)\n    {\n        if ((!visit[i]) && (d2[curr][i] <= time_left))\n        {\n            flag = 1;\n\n            visit[i] = 1;\n\t    temp[count] = i;\n\n            func(d2,visit,time_left-d2[curr][i],time_left_max,i,n,count+1,max,temp,ans);\n\n            visit[i] = 0;\n\t    temp[count] = 0;\n        }\n    }\n\n    if(!flag)\n    {\n        if(count>max)\n        {\n            max = count;\n\t    ans = temp;\n    \t    time_left_max = time_left;\n\t}\n\tif((count==max) && (time_left > time_left_max))\n\t{\n\t    ans = temp;\n   \t    time_left_max = time_left;\n\t}\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin>>t;\n\n    int n,x,max,ind,time_left_max;\n    while(t--)\n    {\n        cin>>n>>x;\n\n        vector<int> arr(n);\n        for(int i=0; i<n; i++)\n            cin>>arr[i];\n\n        vector<vector<int>> d2;\n        vector<int> row(n);\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n                cin>>row[j];\n            d2.push_back(row);\n        }\n\n        vector<bool> visit(n);\n\tvector<int> temp(n);\n\tvector<int> ans(n);\n\n        max = 0;\n        ind = 0;\n        while(ind < n && arr[ind] > x)\n            ind++;\n\n        if(ind < n)\n        {\n            visit[ind] = 1;\n            max = 1;\n\t    ans[0] = ind;\n  \t    time_left_max = x-arr[ind];\n\t    temp[0] = ind;\n            func(d2,visit,x-arr[ind],time_left_max,ind,n,1,max,temp,ans);\n\n            for(int i=ind+1; i<n; i++)\n            {\n                visit[i-1] = 0;\n                visit[i] = 1;\n                if(arr[i] <= x)\n                {\n                    temp[0] = i;\n\t\t    func(d2,visit,x-arr[i],time_left_max,i,n,1,max,temp,ans);\n                }\n            }\n        }\n\n        cout<<max<<\"\\n\";\n\tif(max>0)\n\t{\n\t    for(int i=0; i<max; i++)\n  \t    \tcout<<ans[i]+1<<\" \";\n\t    cout<<\"\\n\";\n\t}\n    }\n\n    return 0;\n}\n"}}},"__N_SSG":true}