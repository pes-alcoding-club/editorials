{"pageProps":{"editorialData":{"editorial":"<p>Title: CNST1</p>\n<p>Difficulty: Easy.</p>\n<p>Prerequisites: Implementation, Graph Theory, BFS.</p>\n<p>Explanation: </p>\n<ol>\n<li>The problem is basically finding the number of connected components, where 2 cells (x, y) and (xx, yy) are said to be connected\nonly if <code>x + 1 = xx</code> or <code>x - 1 = xx</code> or <code>y + 1 = yy</code> or <code>y - 1 = yy</code></li>\n<li>This can be achieved by a simple BFS on the grid.</li>\n<li>Traverse through the array, on every occurence of a '1', perform a BFS with that cell as the root, and delete that particular component from the grid. This can be done either by using a visited array, or just marking the visited cells as 0 in the grid. </li>\n<li>The number of BFSs carried out will provide the value of the number of constallations/components.</li>\n</ol>\n<p>Time Complexity: O(m*n)</p>\n","solutions":{"cpp":"#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a[1005][1005];\r\n\r\nint isValid(int i, int j, int m, int n){\r\n    return i >= 0 && i < m && j >= 0 && j < n;\r\n}\r\n\r\nvoid bfs(int i, int j, int m, int n){\r\n    int directions[4][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}};\r\n    queue<pair<int, int> > q;    \r\n    q.push({i, j});    \r\n    a[i][j] = 0;\r\n    while(!q.empty()) {\r\n        pair<int, int> node = q.front();        \r\n        for(int k=0; k<4; ++k){\r\n            int ii = node.first + directions[k][0];\r\n            int jj = node.second + directions[k][1];\r\n            if(isValid(ii, jj, m, n) && a[ii][jj])\r\n                q.push({ii, jj}), a[ii][jj] = 0;\r\n        }\r\n        q.pop();\r\n    }\r\n}\r\n\r\nvoid solve() {\r\n    int m, n;\r\n    cin >> m >> n;\r\n    for(int i=0; i<m; ++i)\r\n        for(int j=0; j<n; ++j)\r\n            cin >> a[i][j];\r\n    int count = 0;\r\n    for(int i=0; i<m; ++i)\r\n        for(int j=0; j<n; ++j)\r\n            if(a[i][j])\r\n                bfs(i, j, m, n), ++count;\r\n    cout<<count<<\"\\n\";        \r\n}\r\n\r\n\r\nint main(){\r\n    int t;\r\n    cin >> t;\r\n    while(t--)\r\n        solve();\r\n    return 0;\r\n}"},"problemData":{"id":"CNST1","title":"Binary Constellations","difficulty":"easy","problem_url":"https://www.hackerrank.com/contests/alcoding-summer-challenge/challenges/binary-constellations"}}},"__N_SSG":true}