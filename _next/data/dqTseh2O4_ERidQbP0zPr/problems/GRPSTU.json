{"pageProps":{"editorialData":{"editorial":"<p>We can look at the problem as a graph problem, where each student is a node and each friendship is an edge.</p>\n<p>Here the problem requires a bipartite graph check  where each group ruby and emerald can be considered as colors to be assigned to nodes. We need to check if the given graph is bipartite.</p>\n<p>One way to do this is to run a dfs from a node and assign a color to it. Then all its children must be assigned an opposite color.\nWhile runnning the dfs, if we have already visited a child, we must check if it has the same color as its parent.\nIf it does, then it is impossible to color the graph in a bipartite fashion.</p>\n<p>The next observation to be made is that, if a graph is bipartite there are 2 ways to color the graph.\nOne is with the starting node as ruby and all its children as emerald and vice versa.</p>\n<p>The final observation is that, since the graph may have many connected components, the number of ways to color the graph will be 2 ^ (number of connected components) since all colorings of connected components are independent.</p>\n<p>So we need to check for the number of connected components and return 2 ^ (number of connected components).</p>\n<p>Thus the answer is,\n0 if the graph is not bipartite.\nelse it is 2 ^ (number of connected components).</p>\n","solutions":{"cpp":"#include<bits/stdc++.h>\nusing namespace std;\n\nbool dfs(vector<vector<int> >& graph, vector<int>& vis, int i, int c) {\n    if(vis[i] == (c ^ 1)) return false;\n    if(vis[i] != -1) return true;\n    vis[i] = c;\n    bool res = true;\n    for(int x: graph[i]) res = res & dfs(graph, vis, x, c ^ 1);\n    return res;\n}\n\nvoid checkBiPartite(vector<vector<int> >& graph, int n, bool& check, int& count) {\n    vector<int> vis(n + 1, -1);    \n    for(int i = 1; i <= n; ++i) {\n        if(vis[i] == -1) {\n            check &= dfs(graph, vis, i, 1);\n            ++count;\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int f;\n    cin >> f;\n    vector<vector<int> > graph(n + 1, vector<int>());\n    for(int i = 0; i < f; ++i) {\n        int x, y;\n        cin >> x >> y;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n\n    bool check = true; \n    int count = 0;    \n\n    checkBiPartite(graph, n, check, count);\n    \n    if(!check) cout << 0 << endl;    \n    else cout << int(pow(2, count)) << endl;\n    return 0;\n}"},"problemData":{"id":"GRPSTU","title":"Grouping Students","difficulty":"medium","problem_url":"https://www.hackerrank.com/contests/alcoding-summer-challenge-2021/challenges/grouping-students-1"}}},"__N_SSG":true}