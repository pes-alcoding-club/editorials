{"pageProps":{"editorialData":{"editorial":"<p>Tags: Heaps</p>\n<p>The node with the minimum cumulative distance would be the one right in the centre.\nThat node would essentially be the median node based on its distance value.</p>\n<p>The problem's now reduced to keeping track of the median of a list that's being updated.</p>\n<p>Given a list, sorted in ascending order, if we were to know the largest element of the left half of the list, and the smallest element of the right half, we could determine the median of that list.</p>\n<p>Implementation</p>\n<p>To achieve what's required, we could maintian two heaps, a max heap for the left half, and a min heap for the right.\nEach number could be added into one of the two heaps, and the sizes of the heaps could be balanced to make sure they're storing two halves of the current sequence.</p>\n<p>Initialize a max-heap left, and a min-heap right</p>\n<ol>\n<li>If the number is greater than the top of left, it belongs to right, otherwise it belongs to left</li>\n<li>In case the difference in size of the two heaps exceeds 2, the top of either right or left could be shifted to the other heap. (This way, it's guarranteed the size of the two heaps would be equal if there are an even number of elements in the current sequence, or the sizes would differ by exactly 1 in case the sequence size is odd.)</li>\n<li>Since the heaps are always balanced relative to each other, the top of the larger heap will always correspond to the median of the sequence.</li>\n</ol>\n","solutions":{"cpp":"#include<bits/stdc++.h>\nusing namespace std;\n\nvoid addNode(priority_queue<pair<int, int> >&  left,\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int> > >& right, int x, int v) {\n    pair<int, int> node = { v, x };\n    if(node > left.top())\n        right.push(node);\n    else\n        left.push(node);\n    if (left.size() > right.size() + 1) {\n        right.push(left.top());\n        left.pop();\n    } else if (right.size() > left.size() + 1) {\n        left.push(right.top());\n        right.pop();\n    }\n}\n\nint main() {\n    int d, x, v;\n    cin >> d;\n    cin >> x >> v;\n\n    priority_queue<pair<int, int> >  left;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int> > > right;\n\n    left.push({ v, x });\n\n    for(int i = 0; i < d; ++i) {\n        cin >> x >> v;\n        addNode(left, right, x, v);\n        cin >> x >> v;\n        addNode(left, right, x, v);\n        if (left.size() > right.size())\n            cout << left.top().second << \"\\n\";\n        else\n            cout << right.top().second << \"\\n\";\n    }\n\n    return 0;\n} "},"problemData":{"id":"CNODE1","title":"Control Tower","difficulty":"hard","problem_url":"https://www.hackerrank.com/contests/alcoding-summer-challenge-2021/challenges/control-tower"}}},"__N_SSG":true}