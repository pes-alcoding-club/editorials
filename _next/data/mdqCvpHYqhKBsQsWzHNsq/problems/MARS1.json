{"pageProps":{"editorialData":{"editorial":"<h1>Basic Idea</h1>\n<p>Given the constraints, it is clear that this mapping can be represented as a tree and the problem then becomes the LCA problem.</p>\n<h1>Explanation</h1>\n<p>Maintain a graph in the form of an adjacency list. Once you have stored the graph.\nDo a single bfs on the graph, in each step store the depth, parent, and distance from parent of each station and mark this station as visited.\nAfter this, calculate the LCA for A and B in each query by traversing backwards\ntowards the parents of A and B till both the nodes are the same.\nAfter this, starting from A increase the values of distance by the distance between the node\nand the next node in the path and everytime a normal station is encountered, reset distance to zero\nand add the 2 ^ (current distance) to the original cost.\nRepeat this till we reach station B.</p>\n","solutions":{"py":"typeOfStation = []\ngraph = []\ndepth = []\nvisited = []\nparent = []\ndistanceFromParent = []\n\ndef findPath(a, b):\n\n    global depth, parent, visited, distanceFromParent\n\n    pathA = [a]\n    pathB = [b]\n\n    while (a != b):\n        if depth[a] > depth[b]:\n            pathA.append(parent[a])\n            a = parent[a]\n\n        elif depth[b] > depth[a]:\n            pathB.append(parent[b])\n            b = parent[b]\n\n        else:\n            pathA.append(parent[a])\n            pathB.append(parent[b])\n            a = parent[a]\n            b = parent[b]\n\n    pathB = pathB[::-1]\n\n    return (pathA + pathB[1:], a)\n    \n\ndef bfs(root):\n\n    global depth, parent, visited, distanceFromParent\n\n    depth[root] = 0\n    parent[root] = -1\n    visited[root] = 1\n    distanceFromParent[root] = 0\n\n    queue = [root]\n\n    while queue:\n        s = queue.pop()\n\n        for node in graph[s]:\n            neighbour = node[0]\n            if visited[neighbour] == 0:\n                visited[neighbour] = 1\n                queue.append(neighbour)\n                depth[neighbour] = depth[s] + 1\n                parent[neighbour] = s\n                distanceFromParent[neighbour] = node[1]\n    \n\ndef calculate(path, lca):\n\n    global depth, parent, visited, distanceFromParent\n\n    cost = 0\n    distance = 0\n\n    a = path[0]\n    b = path[-1]\n\n    if a == b:\n        return 0\n\n    check = (a != lca)\n\n    while check:\n\n        if (typeOfStation[a] and distance > 0):\n            cost += 2 ** (distance)\n            distance = 0\n        \n        if a == lca:\n            check  = 0\n        else:\n            distance += distanceFromParent[a]\n            a = parent[a]\n\n    check = (a != lca)\n\n    while b != lca:\n\n        if (typeOfStation[b] and distance > 0):\n            cost += 2 ** (distance)\n            distance = 0\n\n        if b == lca:\n            check = 0\n        else:\n            distance += distanceFromParent[b]\n            b = parent[b]\n\n    if distance:\n        cost += 2 ** distance\n\n    return cost\n\nfor _ in range(int(input())):\n\n    graph = []\n    depth = []\n    visited = []\n    parent = []\n    typeOfStation = []\n    distanceFromParent = []\n\n    n, q, c = list(map(int, input().split(' ')))\n    typeOfStation = list(map(int, input().split(' ')))\n\n    graph = [[] for i in range(n)]\n\n    for i in range(n-1):\n        u, v, d = list(map(int, input().split(' ')))\n        graph[u-1].append([v-1, d])\n        graph[v-1].append([u-1, d])\n\n    depth = [-1 for i in range(n)]\n    visited = [0 for i in range(n)]\n    parent = [-1 for i in range(n)]\n    distanceFromParent = [0 for i in range(n)]\n\n    bfs(c - 1)\n\n    for i in range(q):\n        a, b = list(map(int, input().split(' ')))\n        path, lca = findPath(a-1, b-1)\n        ans = calculate(path, lca)\n        print(ans)"},"problemData":{"id":"MARS1","title":"Man Vs. Mars","difficulty":"hard","problem_url":"https://www.hackerrank.com/contests/alcoding-summer-challenge/challenges/mars1"}}},"__N_SSG":true}