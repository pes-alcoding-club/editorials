{"pageProps":{"editorialData":{"editorial":"<p>Title: SPCX2</p>\n<p>Difficulty: Medium.</p>\n<p>Prerequisites: Graph Theory, Depth First Search(DFS) or Disjoint Sets.</p>\n<p>Explanation: </p>\n<ol>\n<li>This problem can be modelled as a Graph Problem. The very first step is to compute how many different countries are there. </li>\n<li>We can either apply Depth First Search (DFS), or the concept of Disjoint Sets, to calculate how many different connected components are present in the graph,\nwhere the vertices are represented by the astronauts, and the astronauts from the same country form one connected component. </li>\n<li>After we get how many connected components are present, we just need to calculate the number of ways of selecting two astronauts from two different connected components. </li>\n<li>So, for the number of ways of selecting two astronauts from different components, we subtract the number of ways of selecting two astronauts from the same component from the total numbers of ways of selecting two astronauts.</li>\n</ol>\n<p>Time Complexity: O(n*p)</p>\n","solutions":{"c":"#include <stdio.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\nint parent[100005], rank[100005] , sets[100005];\r\nint find(int i)\r\n{\r\n    if(parent[i]!=i)\r\n    parent[i] = find(parent[i]);\r\n    return parent[i];    \r\n}\r\nvoid unions(int x , int y)\r\n{\r\n    if(rank[x]>rank[y])\r\n        parent[y] = x ;\r\n    else\r\n    {\r\n        parent[x] = y ;\r\n        if(rank[x]==rank[y])\r\n        rank[y]++;\r\n    }\r\n}\r\nint main() \r\n{\r\n    int i , j , k , m , n ,  p , a , b , x , y;\r\n    long long int sum = 0, sqsum = 0, ans ;\r\n    scanf(\"%d%d\",&n,&m);\r\n    for(i = 0 ; i<n ; i++)\r\n        parent[i] = i ;\r\n    for(i = 0 ; i<m ; i++)\r\n    {\r\n        scanf(\"%d%d\",&a,&b);\r\n        x = find(a);\r\n        y = find(b);\r\n        if(x!=y)\r\n            unions(x,y);\r\n    }\r\n    for(i = 0 ; i<n ; i++)\r\n    {\r\n        x = find(i);\r\n        sets[x]++;\r\n    }\r\n    for(i = 0 ; i<n ; i++)\r\n    {\r\n       if(sets[i])\r\n       {\r\n           sum+=sets[i];\r\n           sqsum+=sets[i]*sets[i];\r\n       }\r\n    }\r\n    ans = (sum*sum - sqsum)/2 ;\r\n    printf(\"%lld\\n\",ans);\r\n    return 0;\r\n}","py":"from sys import stdin\r\n\r\nline = stdin.readline()\r\nv = int(line.split()[0])\r\ne = int(line.split()[1])\r\n\r\nvertexToCluster = dict()\r\nfor vertex in range(0, v):\r\n    vertexToCluster[vertex] = vertex\r\n\r\nclusterToVertices = dict()\r\nfor vertex in range(0, v):\r\n    clusterToVertices[vertex] = [vertex]\r\n\r\nfor i in range(0, e):\r\n    line = stdin.readline()\r\n    v1 = int(line.split()[0])\r\n    v2 = int(line.split()[1])\r\n    if (vertexToCluster[v1] != vertexToCluster[v2]):\r\n        smaller = min(vertexToCluster[v1], vertexToCluster[v2])\r\n        larger = max(vertexToCluster[v1], vertexToCluster[v2])\r\n        for vertex in clusterToVertices[larger]:\r\n            vertexToCluster[vertex] = smaller\r\n            clusterToVertices[smaller].append(vertex)\r\n        del clusterToVertices[larger]\r\n\r\npermutations = v*v\r\nfor c in clusterToVertices:\r\n    permutations -= len(clusterToVertices[c])*len(clusterToVertices[c])\r\n    \r\nprint (int(permutations/2))"}}},"__N_SSG":true}