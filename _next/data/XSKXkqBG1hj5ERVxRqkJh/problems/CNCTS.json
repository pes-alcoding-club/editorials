{"pageProps":{"editorialData":{"editorial":"<p>So for the first subtask, all we had to do is use DFS to check how many places can be visited by the given city after adding the roads.\nSo for each query of type 2, it would take O(N) time complexity.\nFor Q queries, the total time complexity would be O(NQ) which fits the given constraints.</p>\n<p>For the second subtask, we need a faster solution. So for this, we would use a structure called DSU or disjoint set union.\nFor queries of type 1, we would <code>merge</code> (or in other words apply the <code>union</code>) the two cities. This takes O(logN) time complexity for each query.</p>\n<p>As for query 2, we need another data structure within our DSU which stores the size (or in this case, the number of cities we can visit) for each set (or in this case, city).\nIf we do this, we can reduce the time taken to retrieve the size to just O(1).</p>\n<p>So for Q queries our worst case time complexity would be just O(Q log N).</p>\n","solutions":{"cpp":"#include <bits/stdc++.h>\n using namespace std;\n using ll = long long;\n using uint = unsigned int;\n using ull = unsigned long long;\n\n // https://github.com/atcoder/ac-library/blob/master/atcoder/dsu.hpp\n struct DSU {\n  public:\n   DSU(int n) : _n(n + 1), parent_or_size(n + 1, -1) {}\n\n   int merge(int a, int b) {\n     assert(0 <= a && a < this->_n);\n     assert(0 <= b && b < this->_n);\n     int x = this->leader(a), y = this->leader(b);\n     if (x == y) return x;\n     if (-this->parent_or_size[x] < -this->parent_or_size[y]) swap(x, y);\n     this->parent_or_size[x] += this->parent_or_size[y];\n     this->parent_or_size[y] = x;\n     return x;\n   }\n\n   int leader(int a) {\n     assert(0 <= a && a < _n);\n     if (this->parent_or_size[a] < 0) return a;\n     return this->parent_or_size[a] = this->leader(parent_or_size[a]);\n   }\n\n   int size(int a) {\n     assert(0 <= a && a < _n);\n     return -this->parent_or_size[leader(a)];\n   }\n\n  private:\n   int _n;\n   vector<int> parent_or_size;\n };\n\n const int nax = 2e5 + 10;\n\n int main() {\n   cin.tie(0)->sync_with_stdio(0);  // cout << fixed << setprecision(15);\n\n   int n, q, type, a, b;\n   cin >> n >> q;\n\n   DSU dsu(nax);\n\n   while (q--) {\n     cin >> type;\n     if (type == 1) {\n       cin >> a >> b;\n       dsu.merge(a, b);\n     }\n     else {\n       cin >> a;\n       cout << dsu.size(a) << \"\\n\";\n     }\n   }\n\n   return 0;\n }\n"},"problemData":{"id":"CNCTS","title":"Kingdom Cities","difficulty":"hard","problem_url":"https://www.hackerrank.com/contests/alcoding-september-challenge/challenges/kingdom-cities"}}},"__N_SSG":true}