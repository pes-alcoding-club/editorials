{"pageProps":{"editorialData":{"editorial":"<p>We will process boards one at a time. For each board j, count the number of previous board that forms a suitable pair.</p>\n<p>If the jth board is square, boards with at least one dimension equal to w_j are suitable.</p>\n<p>Otherwise, boards with at least one dimension equal to the height and boards with at least one dimension equal to width are suitable. But if we add boards of the first and second types separately, then boards that have both dimension w_j and dimension h_j will be counted twice - the number of such monitors must be subtracted.</p>\n<p>Depending on the data structure used, the complexity of the solution will be O(n) or O(n log n).</p>\n","solutions":{"cpp":"#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  // cout << fixed << setprecision(15);\n\n  int n;\n  cin >> n;\n  map<int, int> match;\n  map<pair<int, int>, int> matchPairs;\n  ll ans = 0;\n  for (int i = 0; i < n; i++) {\n    int h, w;\n    cin >> h >> w;\n    if (h < w) {\n      swap(w, h);\n    }\n    if (w == h) {\n      ans += match[w];\n      match[w]++;\n    } else {\n      ans += match[w] + match[h] - matchPairs[{w, h}];\n      match[w]++;\n      match[h]++;\n      matchPairs[{w, h}]++;\n    }\n  }\n\n  cout << ans << \"\\n\";\n  return 0;\n}\n"},"problemData":{"id":"CRPTR","title":"Carpenter","difficulty":"easy","problem_url":"https://www.hackerrank.com/contests/alcoding-june-challenge-2021/challenges/carpenter"}}},"__N_SSG":true}