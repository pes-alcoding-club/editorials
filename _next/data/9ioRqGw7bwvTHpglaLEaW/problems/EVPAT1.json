{"pageProps":{"editorialData":{"editorial":"<p>Tags: Bitmasks, Hashmaps</p>\n<p>The problem requires us to find the longest substring with an even occurence of some particular numbers. From the statement, it's\nfairly obvious that if we were to store something, we'd have to store the parity of each number's occurence. This, of course can easily be done. But this information alone isn't enough, we'd also need to know the parity of the numbers' occurence at each index, and somehow find\nthe pair of indices that's farthest apart such that the parities are even. This certainly would be an expensive approach, how do we do better.</p>\n<p>Now, it can be noticed that if a particular number D occurs at position x, it occurs an odd number of times in the interval [0, x], and an odd number of times again at a position x + n, then the subarray (x, x + n] contains an even occurence of D. The same if the occurence at x and x + n were even. So, we need a mechanism to compare the parities of the occurence of numbers in B between two indices, if they're the same, then the subarray between those two indices must be considered.</p>\n<p>To remember the parity of the occurence of a particular number until a given index, only 1 bit is required. 0 corresponding to \"even\", and 1 corresponding to \"odd\". The constraints mention that the number of unique elements in B are less than 20. Hence, an integer can easily be\nused to encode this data, where each bit would correspond to the parity of a given number. This integer effectively stores the parity of the occurences of numbers in B till a particular index. Let's call this integer a \"parity mask\". If the parity masks at two indices of the array are the same, it implies that the the subarray between the two indices can be considered for its length.</p>\n<p>All we need to do now is compute the \"parity mask\" for a given index. For this, we need to map a given number in B to a bit position in the \"parity mask\", and keep updating that bit. Now to map a \"parity mask\" to a given index, a hashmap can be used. We need to only remember index of the first occurence of a particular \"parity mask\". Each time we encounter a parity mask, we lookup the hashmap for the first occurence, find the difference between the current index and the first occurence, consider it for our solution.</p>\n<p>Implementation</p>\n<ol>\n<li><code>bitMap</code> is the hashmap that maps a number in B to its bit index in the \"parity mask\"</li>\n<li><code>occur</code> is the hashmap that stores the first occurence of a given \"parity mask\"</li>\n<li><code>cur</code> is the integer used as our \"parity mask\"</li>\n<li>Now, for every element of the array. We check if the number belongs to <code>B</code>. We can use <code>bitMap</code> to check for that condition.\nIf it does, we toggle the parity of the corresponding bit in <code>cur</code>.</li>\n<li>If <code>cur</code> does not exist in <code>occur</code>, it implies that this is the first occurence of <code>cur</code> and we add it to <code>occur</code>.</li>\n<li>Now we check the last occurence of <code>cur</code> in <code>occur</code>. The difference between the current index and the last occurence\nis the length of the longest valid subarray that ends at our current position.</li>\n</ol>\n","solutions":{"cpp":"#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int m, n;\n    cin >> n >> m;\n\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) cin >> a[i];\n    vector<int> b(m);\n    for(int i = 0; i < m; ++i) cin >> b[i];\n\n    map<int, int> bitMap;\n    for(int i = 0; i < m; ++i) bitMap[b[i]] = i;\n\n    map<int, int> occur;\n    int cur = 0;\n    occur[cur] = -1;\n\n    int sol = 0;\n    for(int i = 0; i < n; ++i) {\n        if(bitMap.find(a[i]) != bitMap.end())\n            cur = cur ^ (1 << bitMap[a[i]]);            \n        if(occur.find(cur) == occur.end())\n            occur[cur] = i;\n\n        sol = max(sol, i - occur[cur]);\n    }\n\n    cout << sol << \"\\n\";\n\n\n    return 0;\n} "},"problemData":{"id":"EVPAT1","title":"Even Pattern","difficulty":"hard","problem_url":"https://www.hackerrank.com/contests/alcoding-june-challenge-2021/challenges/even-pattern"}}},"__N_SSG":true}