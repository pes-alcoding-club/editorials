<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Alcoding Club | Editorials</title><link rel="stylesheet" href="https://bootswatch.com/4/lux/bootstrap.min.css"/><link rel="shortcut icon" href="/favicon.ico"/><link rel="preload" href="/editorials/_next/static/css/5b392630e742cc857810.css" as="style"/><link rel="stylesheet" href="/editorials/_next/static/css/5b392630e742cc857810.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/editorials/_next/static/chunks/main-79d6d556cd81f503698e.js" as="script"/><link rel="preload" href="/editorials/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/editorials/_next/static/chunks/framework.cb05d56be993eb6b088a.js" as="script"/><link rel="preload" href="/editorials/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.433bb325642694f7dbf6.js" as="script"/><link rel="preload" href="/editorials/_next/static/chunks/pages/_app-20fc78410fa93af4c468.js" as="script"/><link rel="preload" href="/editorials/_next/static/chunks/pages/problems/%5Bid%5D-2c981d2814853e706423.js" as="script"/></head><body><div id="__next"><div><nav class="navbar navbar-expand-lg navbar-light bg-light"><a class="nav-link" href="/editorials/"><img src="/editorials/logo.jpg" width="80" height="70" alt="the alcoding club logo"/></a><a class="navbar-brand" href="#">Editorials</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor03" aria-controls="navbarColor03" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarColor03"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/editorials/">Home <span class="sr-only">(current)</span></a></li></ul></div></nav><div class="container"><button type="button" class="btn btn-link editorial-link"><a href="https://www.hackerrank.com/contests/alcoding-june-challenge-2021/challenges/even-pattern" target="_blank">View Problem</a></button><div class="jumbotron"><div><p>Tags: Bitmasks, Hashmaps</p>
<p>The problem requires us to find the longest substring with an even occurence of some particular numbers. From the statement, it's
fairly obvious that if we were to store something, we'd have to store the parity of each number's occurence. This, of course can easily be done. But this information alone isn't enough, we'd also need to know the parity of the numbers' occurence at each index, and somehow find
the pair of indices that's farthest apart such that the parities are even. This certainly would be an expensive approach, how do we do better.</p>
<p>Now, it can be noticed that if a particular number D occurs at position x, it occurs an odd number of times in the interval [0, x], and an odd number of times again at a position x + n, then the subarray (x, x + n] contains an even occurence of D. The same if the occurence at x and x + n were even. So, we need a mechanism to compare the parities of the occurence of numbers in B between two indices, if they're the same, then the subarray between those two indices must be considered.</p>
<p>To remember the parity of the occurence of a particular number until a given index, only 1 bit is required. 0 corresponding to "even", and 1 corresponding to "odd". The constraints mention that the number of unique elements in B are less than 20. Hence, an integer can easily be
used to encode this data, where each bit would correspond to the parity of a given number. This integer effectively stores the parity of the occurences of numbers in B till a particular index. Let's call this integer a "parity mask". If the parity masks at two indices of the array are the same, it implies that the the subarray between the two indices can be considered for its length.</p>
<p>All we need to do now is compute the "parity mask" for a given index. For this, we need to map a given number in B to a bit position in the "parity mask", and keep updating that bit. Now to map a "parity mask" to a given index, a hashmap can be used. We need to only remember index of the first occurence of a particular "parity mask". Each time we encounter a parity mask, we lookup the hashmap for the first occurence, find the difference between the current index and the first occurence, consider it for our solution.</p>
<p>Implementation</p>
<ol>
<li><code>bitMap</code> is the hashmap that maps a number in B to its bit index in the "parity mask"</li>
<li><code>occur</code> is the hashmap that stores the first occurence of a given "parity mask"</li>
<li><code>cur</code> is the integer used as our "parity mask"</li>
<li>Now, for every element of the array. We check if the number belongs to <code>B</code>. We can use <code>bitMap</code> to check for that condition.
If it does, we toggle the parity of the corresponding bit in <code>cur</code>.</li>
<li>If <code>cur</code> does not exist in <code>occur</code>, it implies that this is the first occurence of <code>cur</code> and we add it to <code>occur</code>.</li>
<li>Now we check the last occurence of <code>cur</code> in <code>occur</code>. The difference between the current index and the last occurence
is the length of the longest valid subarray that ends at our current position.</li>
</ol>
</div></div><ul class="nav nav-tabs"><li class="nav-item"><a class="nav-link " data-toggle="tab">C++</a></li></ul><pre style="display:block;overflow-x:auto;padding:0.5em;background:#F0F0F0;color:#444"><code style="float:left;padding-right:10px"><span class="react-syntax-highlighter-line-number">1
</span></code><code></code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"editorialData":{"editorial":"\u003cp\u003eTags: Bitmasks, Hashmaps\u003c/p\u003e\n\u003cp\u003eThe problem requires us to find the longest substring with an even occurence of some particular numbers. From the statement, it's\nfairly obvious that if we were to store something, we'd have to store the parity of each number's occurence. This, of course can easily be done. But this information alone isn't enough, we'd also need to know the parity of the numbers' occurence at each index, and somehow find\nthe pair of indices that's farthest apart such that the parities are even. This certainly would be an expensive approach, how do we do better.\u003c/p\u003e\n\u003cp\u003eNow, it can be noticed that if a particular number D occurs at position x, it occurs an odd number of times in the interval [0, x], and an odd number of times again at a position x + n, then the subarray (x, x + n] contains an even occurence of D. The same if the occurence at x and x + n were even. So, we need a mechanism to compare the parities of the occurence of numbers in B between two indices, if they're the same, then the subarray between those two indices must be considered.\u003c/p\u003e\n\u003cp\u003eTo remember the parity of the occurence of a particular number until a given index, only 1 bit is required. 0 corresponding to \"even\", and 1 corresponding to \"odd\". The constraints mention that the number of unique elements in B are less than 20. Hence, an integer can easily be\nused to encode this data, where each bit would correspond to the parity of a given number. This integer effectively stores the parity of the occurences of numbers in B till a particular index. Let's call this integer a \"parity mask\". If the parity masks at two indices of the array are the same, it implies that the the subarray between the two indices can be considered for its length.\u003c/p\u003e\n\u003cp\u003eAll we need to do now is compute the \"parity mask\" for a given index. For this, we need to map a given number in B to a bit position in the \"parity mask\", and keep updating that bit. Now to map a \"parity mask\" to a given index, a hashmap can be used. We need to only remember index of the first occurence of a particular \"parity mask\". Each time we encounter a parity mask, we lookup the hashmap for the first occurence, find the difference between the current index and the first occurence, consider it for our solution.\u003c/p\u003e\n\u003cp\u003eImplementation\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003ebitMap\u003c/code\u003e is the hashmap that maps a number in B to its bit index in the \"parity mask\"\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoccur\u003c/code\u003e is the hashmap that stores the first occurence of a given \"parity mask\"\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecur\u003c/code\u003e is the integer used as our \"parity mask\"\u003c/li\u003e\n\u003cli\u003eNow, for every element of the array. We check if the number belongs to \u003ccode\u003eB\u003c/code\u003e. We can use \u003ccode\u003ebitMap\u003c/code\u003e to check for that condition.\nIf it does, we toggle the parity of the corresponding bit in \u003ccode\u003ecur\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eIf \u003ccode\u003ecur\u003c/code\u003e does not exist in \u003ccode\u003eoccur\u003c/code\u003e, it implies that this is the first occurence of \u003ccode\u003ecur\u003c/code\u003e and we add it to \u003ccode\u003eoccur\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eNow we check the last occurence of \u003ccode\u003ecur\u003c/code\u003e in \u003ccode\u003eoccur\u003c/code\u003e. The difference between the current index and the last occurence\nis the length of the longest valid subarray that ends at our current position.\u003c/li\u003e\n\u003c/ol\u003e\n","solutions":{"cpp":"#include\u003cbits/stdc++.h\u003e\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int m, n;\n    cin \u003e\u003e n \u003e\u003e m;\n\n    vector\u003cint\u003e a(n);\n    for(int i = 0; i \u003c n; ++i) cin \u003e\u003e a[i];\n    vector\u003cint\u003e b(m);\n    for(int i = 0; i \u003c m; ++i) cin \u003e\u003e b[i];\n\n    map\u003cint, int\u003e bitMap;\n    for(int i = 0; i \u003c m; ++i) bitMap[b[i]] = i;\n\n    map\u003cint, int\u003e occur;\n    int cur = 0;\n    occur[cur] = -1;\n\n    int sol = 0;\n    for(int i = 0; i \u003c n; ++i) {\n        if(bitMap.find(a[i]) != bitMap.end())\n            cur = cur ^ (1 \u003c\u003c bitMap[a[i]]);            \n        if(occur.find(cur) == occur.end())\n            occur[cur] = i;\n\n        sol = max(sol, i - occur[cur]);\n    }\n\n    cout \u003c\u003c sol \u003c\u003c \"\\n\";\n\n\n    return 0;\n} "},"problemData":{"id":"EVPAT1","title":"Even Pattern","difficulty":"hard","problem_url":"https://www.hackerrank.com/contests/alcoding-june-challenge-2021/challenges/even-pattern"}}},"__N_SSG":true},"page":"/problems/[id]","query":{"id":"EVPAT1"},"buildId":"94TKz0qrnApQ8QsWloy59","assetPrefix":"/editorials","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"Alcoding Club | Editorials"}],["link",{"rel":"stylesheet","href":"https://bootswatch.com/4/lux/bootstrap.min.css"}],["link",{"rel":"shortcut icon","href":"/favicon.ico"}]]}</script><script nomodule="" src="/editorials/_next/static/chunks/polyfills-57d8738e7416f8423303.js"></script><script src="/editorials/_next/static/chunks/main-79d6d556cd81f503698e.js" async=""></script><script src="/editorials/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/editorials/_next/static/chunks/framework.cb05d56be993eb6b088a.js" async=""></script><script src="/editorials/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.433bb325642694f7dbf6.js" async=""></script><script src="/editorials/_next/static/chunks/pages/_app-20fc78410fa93af4c468.js" async=""></script><script src="/editorials/_next/static/chunks/pages/problems/%5Bid%5D-2c981d2814853e706423.js" async=""></script><script src="/editorials/_next/static/94TKz0qrnApQ8QsWloy59/_buildManifest.js" async=""></script><script src="/editorials/_next/static/94TKz0qrnApQ8QsWloy59/_ssgManifest.js" async=""></script></body></html>